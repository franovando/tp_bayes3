---
title: " "
format:
  pdf:
    pdf-engine: lualatex
    geometry: a4paper
    fontsize: 12pt
    lang: es
    fig-width: 5
    fig-height: 3
    fig-align: center
    colorlinks: true
    code-block-font-size: \scriptsize
    include-in-header:
      text: |
        \usepackage{float}
        \usepackage{caption}
        \usepackage{ragged2e}
        \justifying
execute:
  echo: false
  warning: false
  message: false
  include: true
---

\pagenumbering{gobble}

\begin{titlepage}
\centering
\vspace{2cm}

\includegraphics[width=0.8\textwidth]{logounr.png}

\vspace{2cm}

\text{UNIVERSIDAD NACIONAL DE ROSARIO}

\vspace{1cm}

\text{FACULTAD DE CIENCIAS ECONÓMICAS Y ESTADÍSTICA}

\vspace{3cm}

\Large
\textbf{TRABAJO PRÁCTICO: "El bayesiano interestelar"}

\vspace{1cm}

\fontsize{14pt}{14pt}\selectfont

\text{ESTADÍSTICA BAYESIANA}

\vspace{2cm}

\normalsize

\textbf{Autores: }\text{Priscila Fenoy - María Victoria Fernandez - Francisco Ovando}

\vspace{1cm}

\textbf{Docentes: }\text{Tomás Capretto - Ignacio Evangelista}

\vspace{1cm}

\textbf{Fecha: }\text{9 de Junio de 2025}

\end{titlepage}

\newpage 

\renewcommand{\contentsname}{Índice}
\tableofcontents

\newpage

\pagenumbering{arabic} 

```{=latex}
\renewcommand{\figurename}{Figura}
\renewcommand{\tablename}{Tabla}
```

```{r}
library(tidyverse)
library(rstan)
library(patchwork)
```
# Introducción

En un contexto donde la exploración espacial se vuelve cada vez más relevante, contar con herramientas para comprender y estimar características fundamentales de otros planetas se vuelve clave. En esta oportunidad hemos sido convocados por la Agencia de Investigación Espacial para participar en un experimento crucial: medir la aceleración gravitatoria en un planeta recién descubierto, el Planeta X. La estrategia elegida para tal fin, aunque sencilla en apariencia, exige precisión: lanzar una pelota de tenis verticalmente hacia arriba y registrar detalladamente su trayectoria. Con la ayuda de una nave espacial de última generación y dispositivos tecnológicos capaces de captar con exactitud el movimiento del objeto

Antes de llegar al destino final, el entrenamiento incluyó ensayos previos en la Tierra y una parada intermedia en Marte. Estos pasos no solo sirvieron para familiarizarnos con los instrumentos y condiciones del experimento, sino también para recolectar información valiosa que luego podrá ser utilizada para enriquecer el análisis estadístico.

A lo largo del informe se presentan visualizaciones exploratorias, especificaciones de modelos, implementaciones en `Stan` y análisis de los resultados obtenidos. El objetivo central es obtener una estimación confiable de la gravedad en el Planeta X, así como evaluar el comportamiento predictivo del modelo en distintos escenarios de lanzamiento, contribuyendo así a resolver un interrogante que mantiene en vilo tanto a la comunidad científica como a la población general.

```{r}
datos_marte <- read_csv("tp3_marte.csv")
datos_tierra <- read_csv("tp3_tierra.csv")
datos_planetax <- read_csv("tp3_planetax.csv")
```

# Experimento en el planeta X

Con el objetivo de comenzar a explorar los datos recolectados durante el experimento realizado en el Planeta X, a continuación se presenta la trayectoria registrada de la pelota de tenis en función del tiempo. Esta visualización permite una primera evaluación visual del comportamiento del sistema y del funcionamiento del dispositivo de registro utilizado durante la misión.

\newpage

```{r}
#| label: fig-1
#| fig-cap: "Posición de la pelota en el planeta X durante el experimento" 
ggplot(data = datos_planetax) + 
  geom_point(aes(x=t, y=x_t)) +
  labs(
    x = expression(t),
    y = expression(Y[t])
       ) +
  theme_bw()
```

La @fig-1 muestra una secuencia de mediciones que sigue, en términos generales, la forma esperada para un lanzamiento vertical bajo aceleración constante. La pelota fue lanzada desde una altura de 10 metros y aunque la trayectoria no se ajusta perfectamente a una curva suave, las pequeñas desviaciones observadas pueden atribuirse a errores de medición, propios del instrumento o del entorno experimental. Los datos parecen haber sido recolectados de manera adecuada, por lo que se consideran válidos para avanzar hacia una modelización estadística más precisa.

# Relación entre el modelo cinemático y el modelo lineal normal

En este trabajo se utilizará como base una ecuación fundamental de la 
cinemática que describe el movimiento de un objeto bajo aceleración constante.
Esta, vincula la posición del objeto en función del tiempo con 
parámetros clave del movimiento: la aceleración, la velocidad inicial y la 
posición de partida.

Se trabajará con un modelo lineal normal, donde los coeficientes del mismo
se pueden expresar en función de los parámetros de la ecuación cinemática:

$$\begin{cases}
\beta_0 = x_0 \\
\beta_1 = v_0 \\
\beta_2= \frac12a \\
\end{cases}$$

Además, se puede establecer un vínculo entre las variables de ambos modelos que 
se puede plantear de la siguiente manera:

$$\begin{cases}
X_1 = t \\
X_2 = t^2 \\
\end{cases}$$

A partir de esta relación, se propondrá el modelo estadístico que servirá 
como base para el análisis bayesiano posterior, sin incorporar aún información 
a priori sobre los parámetros.

# Planteo del modelo lineal

A continuación, se presenta el modelo lineal que será utilizado para analizar
los datos obtenidos en el experimento realizado en el Planeta X:

$$
\begin{aligned}
Y_{t_i} \mid \mu_{t_i}, \sigma &\sim \text{Normal}(\mu_{t_i}; \sigma^2) & i = 1, \cdots, 12 \\\\
\mu_{t_i}  = &\beta_0 + \beta_1 t_i + \beta_2 t_i^2
\end{aligned}
$$ 

## Modelo 1: Regresión cuadrática con distribuciones **a priori** uniformes

Este modelo tiene como objetivo describir la relación entre tiempo
transcurrido desde el inicio de la observación (en segundos) denotada
como $t$ y posición vertical final de la pelota después de un tiempo $t$
(en metros) denotada como $y$, a través de una regresión cuadrática con
errores normales. La estimación se realiza bajo el enfoque bayesiano
utilizando el lenguaje probabilístico `Stan`, a través del muestreo
por cadenas de Markov (MCMC).

### Especificación del modelo

El modelo asume que la relación entre $y$ y $t$ puede ser representada
mediante una función cuadrática, es decir:

$$
y_i \sim \mathcal{N}(\mu_i, \sigma), \quad \text{donde} \quad \mu_i = \beta_0 + \beta_1 t_i + \beta_2 t_i^2
$$

donde:

-   $y_i$: valor observado de la posición vertical de la pelota
    en el tiempo $t_i$ (en metros).
-   $\beta_0$: posición vertical inicial de la pelota en $t_i=0$ (en
    metros).
-   $\beta_1$: velocidad inicial de la pelota al comienzo del intervalo
    de tiempo $t_i$ (en metros por segundo).
-   $\beta_2$: el doble de la aceleración constante que experimenta la
    pelota (en metros por segundo al cuadrado).
-   $\sigma$: desviación estándar del error.
-   $t_i$: tiempo transcurrido desde el inicio de la observación (en
    segundos).

### Estructura del modelo expresada en Stan

```{r estructura del modelo 1, echo = TRUE}
modelo1 <- "
data {
  int<lower=0> N;  // Cantidad de observaciones
  vector[N] t;     // Valores de la variable predictora
  vector[N] y;     // Valores de la variable respuesta
}
parameters {
  real beta0;           // Intercepto
  real beta1;           // Pendiente
  real beta2;           // Pendiente
  real<lower=0> sigma;  // Desvio estándar del error
}
model {
  y ~ normal(beta0 + beta1 * t + beta2 * t^2, sigma);
}
generated quantities {
  vector[N] mu;
  vector[N] y_rep;

  // Calcular 'mu'
  mu = beta0 + beta1 * t + beta2 * t^2;

  for (i in 1:N) {
    // Obtención de muestras de la distribución predictiva a posteriori
    y_rep[i] = normal_rng(mu[i], sigma);
  }
}"
```


```{r ajuste del modelo 1}

stan_data_1 <- list(
  N = nrow(datos_planetax),
  t = datos_planetax$t,    
  y = datos_planetax$x_t   
)

modelo_1 <- stan_model(model_code = modelo1)

modelo_1_fit <- sampling(
  modelo_1,             
  data = stan_data_1,   
  chains = 4,           
  seed = 82,          
  refresh = 0,          
)
```

```{r}
muestras_params_1 <- as.data.frame(extract(modelo_1_fit)) %>% 
  select(c(beta0,beta1,beta2,sigma))
```

En este modelo se utilizaron distribuciones *a priori* no informativas, permitiendo que
los datos tengan un rol principal en la actualización de la distribución a
posteriori. Por lo que, las distribuciones *a priori* utilizadas son:

-   Para $\beta_0$, $\beta_1$ y $\beta_2$: distribuciones *a priori* uniformes, el plano se encuentra sobre los reales.

-   Y para $\sigma$: un *prior* uniforme, el plano se encuentra sobre los reales positivos.

Luego de ajustar el modelo bayesiano a los datos obtenidos en el experimento del Planeta X, se generaron muestras de la distribución predictiva a posteriori de la respuesta ($y_{rep}$) a partir de los valores ajustados $\mu$ y el desvío estimado $\sigma$, lo cual permite realizar chequeos de ajuste (posterior predictive checks) para evaluar si el modelo reproduce adecuadamente los patrones observados en los datoS, es decir se analizaron las distribuciones marginales a posteriori de los parámetros del modelo:


```{r}
#| label: fig-2
#| fig-cap: "Distribución marginal de los parámetros estimados obtenidos a partir de\n las muestras generadas" 
#| fig-pos: "H" 

muestras_params_1l <- muestras_params_1 %>% 
  mutate(beta2 = -2 * beta2) %>%
  pivot_longer(c("beta0", "beta1", "beta2", "sigma"), names_to = "parametro") %>%
  mutate(
    parametro = case_when(
      parametro == "beta0" ~ "x[0]",
      parametro == "beta1" ~ "v[0]",
      parametro == "beta2" ~ "a",
      parametro == "sigma" ~ "sigma",
      TRUE ~ parametro
    ),
    parametro = factor(parametro, levels = c("x[0]", "v[0]", "a", "sigma"))
  )

ggplot(muestras_params_1l) +
  geom_histogram(
    aes(x = value, y = after_stat(density)),
    bins = 30,
    fill = "#12BC81",
    color = "#12BC81"
  ) +
  facet_wrap(~ parametro, scales = "free", labeller = label_parsed) +
  labs(x = "Valores de los parámetros", y = "Densidad") +
  theme_bw()
```

En la @fig-2 se muestran las distribuciones a posteriori de los parámetros estimados por el modelo. En todos los casos, se observa que las cadenas convergen a distribuciones unimodales, con densidades concentradas, lo que indica buena estabilidad del muestreo y una adecuada capacidad del modelo para aprender sobre los parámetros. En particular, se observa que:

- El posterior de $a$ presenta una forma aproximadamente simétrica, concentrada en torno a un valor cercano a 6 $m/s^2$. Esto sugiere que la intensidad de la gravedad en el Planeta X es inferior a la terrestre (≈ 9.8 $m/s^2$), pero mayor a la de Marte (≈ 3.7 m/s²).

- El posterior de la velocidad inicial estimada $v_0$ se concentra alrededor de 8 $m/s$, en línea con lo esperado según el entrenamiento previo del astronauta. La forma de la distribución es simétrica y angosta, indicando baja incertidumbre.

- El posterior del valor de $x_0$ se sitúa en torno a los 10 metros, que coincide con la altura de la nave espacial The Bayesian desde donde se realizó el lanzamiento. Esta estimación es coherente con las condiciones iniciales conocidas del experimento.

- A diferencia de las anteriores, el posterior de $\sigma$ es asimétrico y presenta una cola pesada hacia la derecha. Se observa quela mayor concentración cerca de valores bajos sugiere que el modelo logra ajustar bastante bien los datos observados.

# Análisis gráfico del modelo bayesiano
En este ítem se muestra la curva de regresión estimada para la distribución
condicional de $\mu_i$ acompañada de sus bandas de credibilidad del 95%,
que representan la incertidumbre asociada a la 
predicción del modelo ajustado.

```{r include = F}
set.seed(5)
beta0 <- muestras_params_1 %>% slice_sample(n = 40) %>% pull(beta0)
set.seed(5)
beta1 <- muestras_params_1 %>% slice_sample(n = 40) %>% pull(beta1)
set.seed(5)
beta2 <- muestras_params_1 %>% slice_sample(n = 40) %>% pull(beta2)


# Crear dataframe con todas combinaciones: tiempo y curva
curva <- expand.grid(t_f = datos_planetax$t, i = 1:40) %>%
  mutate(
    beta0 = beta0[i],
    beta1 = beta1[i],
    beta2 = beta2[i],
    x_f = beta0 + beta1 * t_f + beta2 * t_f^2
  )

beta0_mean <- mean(muestras_params_1$beta0)
beta1_mean <- mean(muestras_params_1$beta1)
beta2_mean <- mean(muestras_params_1$beta2)

# Curva con coeficientes medios
curva_media <- data.frame(
  t_f = datos_planetax$t,
  x_f = beta0_mean + beta1_mean * datos_planetax$t + beta2_mean * datos_planetax$t^2
)

ggplot() +
  geom_point(
    data = datos_planetax,
    aes(x = t, y = x_t),
    color = "black",
    alpha = 0.7,
    size = 2
  ) +
  geom_line(
    data = curva,
    aes(x = t_f, y = x_f, group = i),
    alpha = 0.4,
    color = "lightblue3"
  ) +
  geom_line(
    data = curva_media,
    aes(x = t_f, y = x_f),
    color = "blue",
    linewidth = 1
  ) +
  theme_bw() +
  labs(x = "Tiempo (segundos)", y = "Altura (metros)")

```

```{r}
#| label: fig-3
#| fig-cap: "Curva de regresión estimada para mu[i] en el modelo 1" 
#| fig-pos: "H" 

x_grid <- seq(0, datos_planetax$t[12], length.out = 100)
mu_matrix <- matrix(nrow = 4000, ncol = 100)

for (i in seq_along(x_grid)) {
  mu_matrix[, i] <- muestras_params_1$beta0 + muestras_params_1$beta1 * x_grid[i] + muestras_params_1$beta2 * x_grid[i]^2
}

mu_mean <- apply(mu_matrix, 2, mean)
mu_qts <- t(apply(mu_matrix, 2, function(x) quantile(x, c(0.025, 0.975))))
mu_qts2 <- t(apply(mu_matrix, 2, function(x) quantile(x, c(0.25, 0.75))))

# Finalmente, se lamacenan los valores calculados en un data frame
data_mu <- data.frame(
  x = x_grid,
  y = mu_mean,
  lower_95 = mu_qts[, 1],
  upper_95 = mu_qts[, 2]
)

ggplot(datos_planetax) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6,
    data = data_mu
  ) +
  geom_point(aes(x = t, y = x_t), alpha = 0.6, size = 2) +
  geom_line(aes(x, y), color = "blue", data = data_mu) +
  theme_bw() +
  labs(
    x = "Tiempo (segundos)",              
    y = "Altura (metros)"              
  )

```
La curva visualizada en la Figura representa la posición esperada de la pelota 
a lo largo del tiempo, según el modelo ajustado con los datos del Planeta X.

La curva sigue una trayectoria parabólica, lo cual es coherente con el 
movimiento de un objeto lanzado hacia arriba bajo la influencia de la 
gravedad. Se observa que la mayoría de los puntos quedan contenidos dentro 
de las bandas de credibilidad, lo que indica un buen ajuste del modelo a los 
datos, aunque con un prior mas informativo esta estimación podría mejorar.

Además, se incluye un gráfico de la distribución predictiva a 
posteriori para distintos valores de tiempo, lo que permite evaluar el 
comportamiento esperado de la pelota en futuros lanzamientos.

```{r}
#| label: fig-4
#| fig-cap: "Distribución predictiva a posteriori en el modelo 2" 
#| fig-pos: "H" 

y_pred_1 <- extract(modelo_1_fit, "y_rep")$y_rep
yp_mean <- apply(y_pred_1, 2, mean)
yp_qts <- t(apply(y_pred_1, 2, function(x) quantile(x, c(0.025, 0.975))))
y_pred_1 <- matrix(y_pred_1, ncol = 1)

predicciones <- data.frame(t = rep(datos_planetax$t, each = 4000), y_pred_1)

data_y_pred <- data.frame(
  x = datos_planetax$t,
  y = yp_mean,
  lower_95 = yp_qts[, 1],
  upper_95 = yp_qts[, 2]
)

ggplot(datos_planetax) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6,
    data = data_y_pred
  ) +
  geom_point(aes(x = t, y = x_t), alpha = 0.6, size = 2) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey10",
    alpha = 0.6,
    data = data_mu
  ) +
  geom_line(aes(x, y), color = "blue", data = data_mu) +
  theme_bw() +
  labs(
    x = "Tiempo (segundos)",              
    y = "Altura (metros)"              
  )
```
En la @fig-4 se observa que las bandas de credibilidad asociadas a la distribución predictiva
a posteriori son bastantes angostas. Esto refleja que el modelo tiene una buena capacidad para predecir futuras observaciones. 

# Construcción de distribuciones a priori informativas a partir de datos de la Tierra y Marte
Se dispone de datos provenientes de experimentos realizados en la Tierra y Marte, cuyos valores de gravedad son conocidos. En este punto, se visualizan dichos datos junto con los del Planeta X, con el objetivo de analizar similitudes y diferencias en los comportamientos registrados. Esta comparación permite identificar patrones útiles para definir distribuciones a priori más informativas para los parámetros del modelo, mejorando así la calidad de las inferencias bayesianas sobre la gravedad en el Planeta X.

```{r}
#| label: fig-5
#| fig-cap: "Posición vertical de la pelota en función del tiempo" 
#| fig-pos: "H" 

datos_planetas <- bind_rows(
  datos_planetax %>% mutate(planeta = "Planeta X"),
  datos_marte %>% mutate(planeta = "Marte"),
  datos_tierra %>% mutate(planeta = "Tierra")
)

ggplot(datos_planetas, aes(x = t, y = x_t, color = planeta)) +
  geom_point(size = 2) +
  scale_color_manual(values = c(
    "Planeta X" = "#2E8B57",
    "Marte" = "#B22222",
    "Tierra" = "#4682B4"
  )) +
  theme_bw() +
  labs(
    x = "Tiempo (segundos)",
    y = "Altura (metros)",
    color = "Planeta"
  )
```

La @fig-5 muestra la posición vertical de la pelota en función del tiempo para los tres planetas. En la Tierra, la pelota alcanza una menor altura y regresa rápidamente al suelo, lo que refleja una mayor aceleración gravitatoria. En el Planeta X, se observa una altura intermedia y un tiempo de vuelo moderado, mientras que en Marte la pelota alcanza la mayor altura y permanece más tiempo en el aire, lo que sugiere una gravedad más débil.

En conjunto, los datos sugieren que la gravedad en el Planeta X es más cercana a la de la Tierra que a la de Marte. Esta comparación proporciona una base útil para definir distribuciones a priori informativas sobre la gravedad en el planeta de interés, aprovechando el conocimiento disponible sobre los entornos conocidos.


# ITEM 7

$\beta_0\sim N(10,0.5)$ $\beta_1\sim N(8,1)$ $\beta_2\sim N(-4,1.5)$
$\sigma\sim N^+(1.5)$

grav marte 3.73 grav tierra 9.807 media 6.7685

-0.5\*(6.7685)

```{r estructura del modelo 2, echo=T}
modelo2 <- "
data {
  int<lower=0> N;  // Cantidad de observaciones
  vector[N] t;     // Valores de la variable predictora
  vector[N] y;     // Valores de la variable respuesta
}
parameters {
  real beta0;           // Intercepto
  real beta1;           // Pendiente
  real beta2;           // Pendiente
  real<lower=0> sigma;  // Desvio estándar del error
}
model {
  beta0 ~ normal(10, 0.5);
  beta1 ~ normal(8, 1);
  beta2 ~ normal(-4, 1.5);
  sigma ~ normal(0, 1.5);
  y ~ normal(beta0 + beta1 * t + beta2 * t^2, sigma);
}
generated quantities {
  vector[N] mu2;
  vector[N] y_rep2;

  // Calcular 'mu'
  mu2 = beta0 + beta1 * t + beta2 * t^2;

  for (i in 1:N) {
    // Obtención de muestras de la distribución predictiva a posteriori
    y_rep2[i] = normal_rng(mu2[i], sigma);
  }
}"
```


```{r ajuste del modelo 2}
stan_data_2 <- list(
  N = nrow(datos_planetax),
  t = datos_planetax$t,    
  y = datos_planetax$x_t   
)

modelo_2 <- stan_model(model_code = modelo2)

modelo_2_fit <- sampling(
  modelo_2,             
  data = stan_data_2,   
  chains = 4,           
  seed = 82,          
  refresh = 0,          
)
```

```{r}
set.seed(93)
t_grilla <- rep(datos_planetax$t, each = 1000)
beta0_priori <- rep(rnorm(1000, 10, 0.5), times = 12)
beta1_priori <-  rep(rnorm(1000, 8, 1), times = 12)
beta2_priori <- rep(rnorm(1000, -4, 1.5), times = 12)
sigma_priori <- rep(abs(rnorm(1000, 0, 1.5)), times = 12)
mu_priori <- beta0_priori + beta1_priori * t_grilla + beta2_priori * t_grilla^2
y_pred_priori <- rnorm(12000, mu_priori, sigma_priori)
priori <- data.frame(
  t_grilla,
  y_pred_priori,
  beta0_priori,
  beta1_priori,
  beta2_priori,
  mu_priori,
  sigma_priori,
  i = 1:1000
) %>% arrange(i, t_grilla)
```

```{r}
#| label: fig-6
#| fig-cap: "Distribución predictiva a priori de la posición vertical de la pelota" 
#| fig-pos: "H" 

# Resumen por tiempo
summary_priori <- priori %>%
  group_by(t_grilla) %>%
  summarise(
    q05 = quantile(y_pred_priori, 0.05),
    q95 = quantile(y_pred_priori, 0.95),
    mean = mean(y_pred_priori)
  )

# Gráfico
ggplot(summary_priori, aes(x = t_grilla)) +
  geom_ribbon(aes(ymin = q05, ymax = q95),
              fill = "lightblue",
              alpha = 0.4) +
  geom_line(aes(y = mean), color = "blue", linewidth = 1) +
  labs( x = "Tiempo(segundos)", y = "Altura(segundos)") +
  theme_minimal()
```


```{r}
#| label: fig-7
#| fig-cap: "Distribución predictiva a priori en distintos valores del tiempo" 
#| fig-pos: "H" 

# Seleccionamos algunos puntos de t
t_values <- unique(priori$t_grilla)
t_seleccionados <- t_values[seq(1, length(t_values), length.out = 6)]

# Filtrar esos tiempos
muestra <- priori %>% filter(t_grilla %in% t_seleccionados)

ggplot(muestra, aes(x = y_pred_priori)) +
  geom_histogram(bins = 30,
                 fill = "gray80",
                 color = "black") +
  facet_wrap( ~ round(t_grilla, 2), scales = "free", ncol = 3) +
  labs(x = expression(y[pred])) +
  theme_minimal()
```

```{r}
muestras_params_2 <- as.data.frame(extract(modelo_2_fit)) %>%
  select(c(beta0, beta1, beta2, sigma))
```

```{r}
#| label: fig-8
#| fig-cap: "Distribución marginal de los parámetros estimados obtenidos a partir de\n las muestras generadas para el segundo modelo" 
#| fig-pos: "H" 

muestras_params_2l <- muestras_params_2 %>%
  mutate(beta2 = -2 * beta2) %>%
  pivot_longer(c("beta0", "beta1", "beta2", "sigma"), names_to = "parametro") %>%
  mutate(
    parametro = case_when(
      parametro == "beta0" ~ "x[0]",
      parametro == "beta1" ~ "v[0]",
      parametro == "beta2" ~ "a",
      TRUE ~ parametro
    )
  )

ggplot(muestras_params_2l) +
  geom_histogram(
    aes(x = value, y = after_stat(density)),
    bins = 30,
    fill = "#12BC81",
    color = "#12BC81"
  ) +
  facet_wrap(~ parametro, scales = "free", labeller = label_parsed) +  
  labs(x = "Valores de los parámetros", y = "Densidad") +
  theme_bw()
```

```{r, include=F}
set.seed(5)
beta0_mod2 <- muestras_params_2 %>% slice_sample(n = 40) %>% pull(beta0)
set.seed(5)
beta1_mod2 <- muestras_params_2 %>% slice_sample(n = 40) %>% pull(beta1)
set.seed(5)
beta2_mod2 <- muestras_params_2 %>% slice_sample(n = 40) %>% pull(beta2)


# Crear dataframe con todas combinaciones: tiempo y curva
curva2 <- expand.grid(t_f = datos_planetax$t, i = 1:40) %>%
  mutate(
    beta0 = beta0_mod2[i],
    beta1 = beta1_mod2[i],
    beta2 = beta2_mod2[i],
    x_f = beta0_mod2 + beta1_mod2 * t_f + beta2_mod2 * t_f^2
  )

beta0_mean2 <- mean(muestras_params_2$beta0)
beta1_mean2 <- mean(muestras_params_2$beta1)
beta2_mean2 <- mean(muestras_params_2$beta2)

# Curva con coeficientes medios
curva_media2 <- data.frame(
  t_f = datos_planetax$t,
  x_f = beta0_mean2 + beta1_mean2 * datos_planetax$t + beta2_mean2 * datos_planetax$t^2
)

ggplot() +
  geom_point(
    data = datos_planetax,
    aes(x = t, y = x_t),
    color = "black",
    alpha = 0.7,
    size = 2
  ) +
  geom_line(
    data = curva2,
    aes(x = t_f, y = x_f, group = i),
    alpha = 0.7,
    color = "lightblue"
  ) +
  geom_line(
    data = curva_media2,
    aes(x = t_f, y = x_f),
    color = "blue",
    linewidth = 1
  ) +
  theme_bw() +
  labs(x = "Tiempo (en segundos)", y = "Altura (en metros)")
```

```{r}
#| label: fig-9
#| fig-cap: "Curva de regresión estimada para mu[i] en el modelo 2" 
#| fig-pos: "H"

x_grid <- seq(0, datos_planetax$t[12], length.out = 100)
mu_matrix2 <- matrix(nrow = 4000, ncol = 100)

for (i in seq_along(x_grid)) {
  mu_matrix2[, i] <- muestras_params_2$beta0 + muestras_params_2$beta1 * x_grid[i] + muestras_params_2$beta2 * x_grid[i]^2
}

mu_mean2 <- apply(mu_matrix2, 2, mean)
mu_qts2 <- t(apply(mu_matrix2, 2, function(x)
  quantile(x, c(0.025, 0.975))))

# Finalmente, se lamacenan los valores calculados en un data frame
data_mu2 <- data.frame(
  x = x_grid,
  y = mu_mean2,
  lower_95 = mu_qts2[, 1],
  upper_95 = mu_qts2[, 2]
)

ggplot(datos_planetax) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6,
    data = data_mu2
  ) +
  geom_point(aes(x = t, y = x_t), alpha = 0.6, size = 2) +
  geom_line(aes(x, y), color = "blue", data = data_mu2) +
  labs( x = "Tiempo(segundos)", y = "Altura(segundos)") +
  theme_bw()
```

```{r}
#| label: fig-10
#| fig-cap: "Distribución predictiva a posteriori en el modelo 2" 
#| fig-pos: "H"
y_pred_2 <- extract(modelo_2_fit, "y_rep2")$y_rep2
yp_mean2 <- apply(y_pred_2, 2, mean)
yp_qts2 <- t(apply(y_pred_2, 2, function(x)
  quantile(x, c(0.025, 0.975))))
y_pred_2 <- matrix(y_pred_2, ncol = 1)

predicciones2 <- data.frame(t = rep(datos_planetax$t, each = 4000), y_pred_2)

# Finalmente, se lamacenan los valores calculados en un data frame
data_y_pred2 <- data.frame(
  x = datos_planetax$t,
  y = yp_mean2,
  lower_95 = yp_qts2[, 1],
  upper_95 = yp_qts2[, 2]
)

ggplot(datos_planetax) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6,
    data = data_y_pred2
  ) +
  geom_point(aes(x = t, y = x_t), alpha = 0.6, size = 2) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey10",
    alpha = 0.6,
    data = data_mu2
  ) +
  geom_line(aes(x, y), color = "blue", data = data_mu2) +
  labs( x = "Tiempo(segundos)", y = "Altura(segundos)")+
  theme_bw()
```

```{r}
#| label: fig-11
#| fig-cap: "Distribución de la gravedad en ambos modelos" 
#| fig-pos: "H"
a_mod1 <- muestras_params_1l %>% filter(parametro == 'a') %>% pull(value)
a_mod2 <- muestras_params_2l %>% filter(parametro == 'a') %>% pull(value)

gravedad <- data.frame(modelo = rep(c("Modelo 1", "Modelo 2"), each = 4000),
                       a = c(a_mod1, a_mod2))
ggplot(gravedad) +
  geom_histogram(
    aes(x = a, y = after_stat(density)),
    bins = 30,
    fill = "#12BC81",
    color = "#12BC81"
  ) +
  facet_wrap( ~ modelo) +
  labs(x = "Gravedad", y = "Densidad") +
  theme_bw()

ggplot(gravedad) +
  geom_boxplot(aes(y = a, x = modelo), fill = "#12BC81") +
  labs(y = "Gravedad", x = "Modelo") +
  theme_bw()
```

```{r}
quantile(a_mod1, c(0.025, 0.25, 0.75, 0.975))
quantile(a_mod2, c(0.025, 0.25, 0.75, 0.975))
```



```{r, include=F}
x_grid <- seq(0, datos_planetax$t[12], length.out = 100)
mu_matrix_10.1 <- matrix(nrow = 4000, ncol = 100)
for (i in seq_along(x_grid)) {
  mu_matrix_10.1[, i] <- muestras_params_1$beta0 + 6 * x_grid[i] + muestras_params_1$beta2 * x_grid[i]^2
}

mu_mean_10.1 <- apply(mu_matrix_10.1, 2, mean)
mu_qts_10.1 <- t(apply(mu_matrix_10.1, 2, function(x)
  quantile(x, c(0.025, 0.975))))

# Finalmente, se lamacenan los valores calculados en un data frame
data_mu_10.1 <- data.frame(
  x = x_grid,
  y = mu_mean_10.1,
  lower_95 = mu_qts_10.1[, 1],
  upper_95 = mu_qts_10.1[, 2]
)

p1 <- ggplot(datos_planetax) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6,
    data = data_mu_10.1
  ) +
  # geom_point(aes(x = t, y = x_t), alpha = 0.6, size = 2) +
  geom_line(aes(x, y), color = "blue", data = data_mu_10.1) +
  theme_bw()


mu_matrix_10.2 <- matrix(nrow = 4000, ncol = 100)

for (i in seq_along(x_grid)) {
  mu_matrix_10.2[, i] <- muestras_params_2$beta0 + 6 * x_grid[i] + muestras_params_2$beta2 * x_grid[i]^2
}

mu_mean_10.2 <- apply(mu_matrix_10.2, 2, mean)
mu_qts_10.2 <- t(apply(mu_matrix_10.2, 2, function(x) quantile(x, c(0.025, 0.975))))

# Finalmente, se lamacenan los valores calculados en un data frame
data_mu_10.2 <- data.frame(
  x = x_grid,
  y = mu_mean_10.2,
  lower_95 = mu_qts_10.2[, 1],
  upper_95 = mu_qts_10.2[, 2]
)

p2 <- ggplot(datos_planetax) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6,
    data = data_mu_10.2
  ) +
  # geom_point(aes(x = t, y = x_t), alpha = 0.6, size = 2) +
  geom_line(aes(x, y), color = "blue", data = data_mu_10.2) +
  theme_bw()
p1 + p2
```

```{r, include=F}
x_grid <- seq(0, 6, length.out = 100)
mu_matrix_10.3 <- matrix(nrow = 4000, ncol = 100)

for (i in seq_along(x_grid)) {
  mu_matrix_10.3[, i] <- muestras_params_1$beta0 + 12 * x_grid[i] + muestras_params_1$beta2 * x_grid[i]^2
}

mu_mean_10.3 <- apply(mu_matrix_10.3, 2, mean)
mu_qts_10.3 <- t(apply(mu_matrix_10.3, 2, function(x)
  quantile(x, c(0.025, 0.975))))

# Finalmente, se lamacenan los valores calculados en un data frame
data_mu_10.3 <- data.frame(
  x = x_grid,
  y = mu_mean_10.3,
  lower_95 = mu_qts_10.3[, 1],
  upper_95 = mu_qts_10.3[, 2]
)

p3 <- ggplot(datos_planetax) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6,
    data = data_mu_10.3
  ) +
  # geom_point(aes(x = t, y = x_t), alpha = 0.6, size = 2) +
  geom_line(aes(x, y), color = "blue", data = data_mu_10.3) +
  theme_bw()


mu_matrix_10.4 <- matrix(nrow = 4000, ncol = 100)

for (i in seq_along(x_grid)) {
  mu_matrix_10.4[, i] <- muestras_params_2$beta0 + 12 * x_grid[i] + muestras_params_2$beta2 * x_grid[i]^2
}

mu_mean_10.4 <- apply(mu_matrix_10.4, 2, mean)
mu_qts_10.4 <- t(apply(mu_matrix_10.4, 2, function(x)
  quantile(x, c(0.025, 0.975))))

# Finalmente, se lamacenan los valores calculados en un data frame
data_mu_10.4 <- data.frame(
  x = x_grid,
  y = mu_mean_10.4,
  lower_95 = mu_qts_10.4[, 1],
  upper_95 = mu_qts_10.4[, 2]
)

p4 <- ggplot(datos_planetax) +
  geom_ribbon(
    aes(x, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6,
    data = data_mu_10.4
  ) +
  # geom_point(aes(x = t, y = x_t), alpha = 0.6, size = 2) +
  geom_line(aes(x, y), color = "blue", data = data_mu_10.4) +
  theme_bw()
p3 + p4
```

Queremos ver cuánto tarda en caer la pelota en promedio

$$
\mu=0 \to \beta_0+\beta_1t+\beta_2t^2=0 \to t_{1,2}=\frac{-\beta_1\pm\sqrt{\beta_1^2-4\beta_0\beta_2}}{2\beta_2}
$$
```{r}
# Despeje de t de la ecuación
t_caida_6ms.1 <- muestras_params_1 %>% 
  mutate(
  t = (-6-sqrt(6^2-4*beta0*beta2))/(2*beta2)
  ) %>% 
  select(-c(sigma, beta1))
t_caida_6ms.2 <- muestras_params_2 %>% 
  mutate(
  t = (-6-sqrt(6^2-4*beta0*beta2))/(2*beta2)
  ) %>% 
  select(-c(sigma, beta1))

g6ms.1 <- t_caida_6ms.1 %>% ggplot() +
geom_histogram(
    aes(x = t, y = after_stat(density)),
    bins = 30,
    fill = "#12BC81",
    color = "#12BC81"
  ) +
  lims(
    x = c(2,5),
    y = c(0,3.5)
    ) +
  theme_bw()

g6ms.2 <- t_caida_6ms.2 %>% ggplot() +
geom_histogram(
    aes(x = t, y = after_stat(density)),
    bins = 30,
    fill = "#12BC81",
    color = "#12BC81"
  ) +
  lims(
    x = c(2,5),
    y = c(0,3.5)   
       ) +
  theme_bw()

t_caida_12ms.1 <- muestras_params_1 %>% 
  mutate(
  t = (-12-sqrt(12^2-4*beta0*beta2))/(2*beta2)
  ) %>% 
  select(-c(sigma, beta1))
t_caida_12ms.2 <- muestras_params_2 %>% 
  mutate(
  t = (-12-sqrt(12^2-4*beta0*beta2))/(2*beta2)
  ) %>% 
  select(-c(sigma, beta1))

g12ms.1 <- t_caida_12ms.1 %>% ggplot() +
geom_histogram(
    aes(x = t, y = after_stat(density)),
    bins = 30,
    fill = "#12BC81",
    color = "#12BC81"
  ) +
  lims(
    x = c(3,7),
    y = c(0,2)   
       ) +
  theme_bw()

g12ms.2 <-t_caida_12ms.2 %>% ggplot() +
geom_histogram(
    aes(x = t, y = after_stat(density)),
    bins = 30,
    fill = "#12BC81",
    color = "#12BC81"
  ) +
  lims(
    x = c(3,7),
    y = c(0,2)   
       ) +
  theme_bw()

g6ms.1 + g6ms.2

g12ms.1 + g12ms.2
```


